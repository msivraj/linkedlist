/*
 * Linkedlist.h
 *
 *  Created on: Oct 22, 2016
 *      Author: msivraj
 */

#ifndef STUDENT_CODE_LINKEDLIST_H_
#define STUDENT_CODE_LINKEDLIST_H_
#include "LinkedListInterface.h"
#include "Node.h"
#include <iostream>
#include <stdexcept>

namespace std {
template<class T> class Linkedlist: public LinkedListInterface<T> {
private:
	Node<T>* head;
	Node<T>* tail;
	Node<T>* current;

public:
	Linkedlist() {
		head = NULL;
		tail = NULL;
		current = NULL;

	}

	virtual ~Linkedlist() {


		clear();
	}

	void printList()
	 {
		current = head;
		while (current != NULL) {
			cout << current->getValue() << ", ";
			current = current->getNext();
		}

	}
	bool isDuplicate(T valueIn) {
		cout
				<< "?????????????????????????????????????????????? is duplicate ??????????????????????????????????????????????????????????"
				<< valueIn << "\n";
		Node<T>* dummyCurrent = head;
		while (dummyCurrent != NULL) {
			if (valueIn == dummyCurrent->getValue()) {
				return false;
			}
			dummyCurrent = dummyCurrent->getNext();
		}
		return true;
	}



	/*
	 insertHead

	 A node with the given value should be inserted at the beginning of the list.

	 Do not allow duplicate values in the list.
	 */
	virtual void insertHead(T value) {
		cout
				<< "??????????????????????????????????????????????Insert Head??????????????????????????????????????????????????????????"
				<< value << "\n";
		if (isDuplicate(value)) {
			Node<T>* headNode = new Node<T>(value);
			if (tail == NULL && head == NULL) {
				head = headNode;
				tail = headNode;
				current = headNode;
			} else {
				//Node<T>* headNode = new Node<T>(value);
				headNode->setNext(head);
				head->setPrevious(headNode);
				head = headNode;
				current = headNode;
			}
		}
		
	}

	virtual void insertTail(T value) {
		cout
				<< "??????????????????????????????????????????????Insert tail??????????????????????????????????????????????????????????"
				<< value << "\n";
		if (isDuplicate(value)) {
/////////////////////////////////////////////////problem seg fault always removes last value when inserting a new tail

			if (tail == NULL && head == NULL) {
				Node<T>* tailNode = new Node<T>(value);
				tail = tailNode;
				head = tailNode;
				current = tailNode;
			} else {
				Node<T>* tailNode = new Node<T>(value);
				tailNode->setPrevious(tail);
				tail->setNext(tailNode);
				tail = tailNode;
			}
		}

		

	}
	/*
	 insertAfter

	 A node with the given value should be inserted immediately after the
	 node whose value is equal to insertionNode.

	 A node should only be added if the node whose value is equal to
	 insertionNode is in the list. Do not allow duplicate values in the list.
	 */
	virtual void insertAfter(T value, T insertionNode) {
		cout
				<< "?????????????????????????????????????????????? Insert after ??????????????????????????????????????????????????????????"
				<< value << ", " << insertionNode << "\n";

		//int originalSize = size();
		if (isDuplicate(value)) {
			Node<T>*dummyCurrent = head;
			//while (size() == originalSize)
			while (dummyCurrent != NULL) {
			//current;
			if (dummyCurrent->getValue() == insertionNode) {
				Node<T>* insertNode = new Node<T>(value);
				Node<T>* beforeInsertNode = dummyCurrent;
				Node<T>* afterInsertNode = dummyCurrent->getNext();
					if (afterInsertNode == NULL) {
						//insertNode->setNext(afterInsertNode);
						//insertNode->setPrevious(beforeInsertNode);
						//beforeInsertNode->setNext(insertNode);
						//afterInsertNode->setPrevious(insertNode);
						//tail=insertNode;
						insertTail(value);
					} else {
						insertNode->setPrevious(beforeInsertNode);
						insertNode->setNext(afterInsertNode);
						beforeInsertNode->setNext(insertNode);
						afterInsertNode->setPrevious(insertNode);
					}


					
				}


			dummyCurrent = dummyCurrent->getNext();
			//count++;

			}
		}

		
	}
	/*
	 remove

	 The node with the given value should be removed from the list.

	 The list may or may not include a node with the given value.
	 */

	virtual void remove(T value) {
		cout
				<< "?????????????????????????????????????????????? remove ??????????????????????????????????????????????????????????"
				<< value << "\n";
		current = head;
		Node<T>* nodeAfterNodeToRemove;
		Node<T>* nodeBeforeNodeToRemove;
		while (current != NULL) {
			if (current->getValue() == value) {
				//Node<T>* dummyCurrent = current;
				nodeBeforeNodeToRemove = current->getPrevious();
				nodeAfterNodeToRemove = current->getNext();
				delete current;
				if (size() == 1) {
					delete current;
					head = NULL;
					tail = NULL;
					current = NULL;
				}
				else if (nodeAfterNodeToRemove != NULL
						&& nodeBeforeNodeToRemove != NULL) {
					nodeBeforeNodeToRemove->setNext(nodeAfterNodeToRemove);
					nodeAfterNodeToRemove->setPrevious(nodeBeforeNodeToRemove);
					current = nodeAfterNodeToRemove;
				}

				else if (nodeAfterNodeToRemove == NULL) {
					current = nodeBeforeNodeToRemove;
					current->setNext(NULL);
					tail = current;

				} else if (nodeBeforeNodeToRemove == NULL) {
					current = nodeAfterNodeToRemove;
					current->setPrevious(NULL);
					head = current;
				}
				//delete dummyCurrent;

				break;

			}
			current = current->getNext();

		

		}
	}

	virtual void clear() {
		cout
				<< "?????????????????????????????????????????????? clear ??????????????????????????????????????????????????????????\n";
		Node<T>* dummyDelete = head;
		int theSize = size();
		while (theSize != 0) {
			head = head->getNext();
			delete dummyDelete;
			dummyDelete = head;
			theSize--;
		}
		//delete head;
		head = NULL;
		tail = NULL;


	}

			/*Node *pDel = head;
		while (pDel != NULL) {
			head = head->getNext();
			delete pDel;
			 update the head node
			pDel = _pHead;
		}
			 /Reset the head and tail node
		_pTail = _pHead = NULL;
			 }*/

	/*
	 at

	 Returns the value of the node at the given index. The list begins at
	 index 0.

	 If the given index is out of range of the list, throw an out of range exception.
	 */

	virtual T at(int index) {
		cout
				<< "?????????????????????????????????????????????? at ??????????????????????????????????????????????????????????"
				<< index << "\n";
		//T nodeValue;
		Node<T>* nodeValue;
		int count = 0;

		if (index < 0 || index >= size()) {
			throw out_of_range("index is out of range");
		}
		///////////////////////////current should not be NULL but it is why?????????????????????
		else {
			current = head;
			while (current != NULL) {
				if (count == index) {
					nodeValue = current;
				}

				current = current->getNext();
				count++;

			}
		}


		return nodeValue->getValue();
	}

	virtual int size() {
		
		int count = 0;
		//Node<T> *tailDummy = tail;
		current = head;
		while (current != NULL) {
			//cout << "next from current " << current->getNext();
			current = current->getNext();
			count++;
		}
		cout
				<< "?????????????????????????????????????????????? size ??????????????????????????????????????????????????????????"
				<< count << "\n";
		return count;
	}
};

} /* namespace std */

#endif /* STUDENT_CODE_LINKEDLIST_H_ */
